<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Campus Maps</title>
    <link rel="stylesheet" href="/pages/map/css/map.css" />
    <!-- SweetAlert2 Library -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  </head>

  <script>
    // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏´‡∏•‡∏î‡∏ü‡πâ‡∏≠‡∏ô‡∏ï‡πå‡∏à‡∏≤‡∏Å localStorage
    function loadFontSetting() {
      const savedFont = localStorage.getItem("selectedFont");
      if (savedFont) {
        document.body.style.fontFamily = savedFont; // ‡∏ï‡∏±‡πâ‡∏á‡∏ü‡πâ‡∏≠‡∏ô‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡∏à‡∏≤‡∏Å localStorage
      }
    }
    loadFontSetting(); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÇ‡∏´‡∏•‡∏î
  </script>

  <body>
    <nav>
      <div class="container">
        <div class="nav-content">
          <h1>üó∫Ô∏è Campus Maps</h1>
          <div class="nav-links">
            <a href="/index.html">Home</a>
            <a href="map.html" class="active">Maps</a>
          </div>
        </div>
      </div>
    </nav>

    <div id="map-container">
      <div class="container">
        <canvas id="myCanvas" width="1423px" height="653px"></canvas>
        <div id="map-controls">
          <div class="controls-group">
            <label for="mapName">Map Name:</label>
            <select id="map-select">
              <option value="">Select Map</option>
            </select>
            <input type="text" id="mapName" placeholder="Enter map name" />
            <button id="updateMapName">Update Map Name</button>
            <button id="delete-map">üóëÔ∏è Delete Map</button>

            <div class="upload-btn-wrapper">
              <button class="btn-upload">
                üì§ Upload Map
                <input type="file" id="map-upload" accept="image/*" />
              </button>
            </div>

            <input type="text" id="pointName" placeholder="Enter point name" />
            <button id="resetPoints">üîÑ Reset</button>
            <!-- <button id="ToggleMode">üîÑ Toggle Mode</button> -->
          </div>

          <div class="controls-group">
            <select id="pointSelect"></select>
            <button id="DeletePoint">üóëÔ∏è Delete Point</button>
            <select id="point1Select"></select>
            <select id="point2Select"></select>
            <button id="ShowDistance">üìè Show Distance</button>
            <select id="editPointSelect"></select>
            <input
              type="text"
              id="newPointName"
              placeholder="Enter new point name"
            />
            <button id="editPoint">‚úèÔ∏è Update Point Name</button>
          </div>
        </div>

        <!-- <div id="modeIndicator"></div> -->
        <div id="distanceDisplay"></div>
      </div>
    </div>

    <div
      id="tooltip"
      style="
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 0.8rem;
        border-radius: 6px;
        font-size: 0.9rem;
        position: absolute;
        display: none;
        background-color: white;
        border: 1px solid black;
        pointer-events: none;
      "
    ></div>

    <div id="map-sample-container" class="container">
      <h3>Example Maps</h3>
      <div class="map-samples">
        <img
          src="./map1.jpg"
          alt="Sample Map 1"
          class="map-sample"
          data-map-src="./map1.jpg"
        />
        <img
          src="./map2.jpg"
          alt="Sample Map 2"
          class="map-sample"
          data-map-src="./map2.jpg"
        />
        <img
          src="./map3.jpg"
          alt="Sample Map 3"
          class="map-sample"
          data-map-src="./map3.jpg"
        />
      </div>
    </div>

    <!-- <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
        import { getDatabase, ref, get, onValue } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCFhkQgV566VA1QjexbaCsAJ8iCfQXpW0g",
            authDomain: "esp8266-t1-37f02.firebaseapp.com",
            databaseURL: "https://esp8266-t1-37f02-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "esp8266-t1-37f02",
            storageBucket: "esp8266-t1-37f02.appspot.com",
            messagingSenderId: "201166852539",
            appId: "1:201166852539:web:42c3ad90a0611b17d5b49e"
        };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app), dbRef = ref(db, "Data");
        let pointsPerMap = []; // ‡∏™‡∏£‡πâ‡∏≤‡∏á array ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏à‡∏∏‡∏î‡∏ï‡∏≤‡∏°‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
        let markerCoordinatesPerMap = {};  // ‡πÉ‡∏ä‡πâ‡πÄ‡∏Å‡πá‡∏ö marker ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà

        const tooltip = document.getElementById("tooltip");
        const canvas = document.getElementById("myCanvas"), ctx = canvas.getContext("2d");
        let points = [], drawMode = true, markerCoordinates = [], maps = [];

        const img = new Image();
        const mapSamples = [
            { src: './2.jpg', name: '' },
            { src: './3.jpg', name: '' }
        ];

        // Check condition
        const CheckCondition = {
            Equal: function (condition, massageAlert) {
                if (condition === "" || condition === null) {
                    Swal.fire({
                        title: "Warning",
                        text: massageAlert,
                        icon: "warning"
                    });
                    return;
                }
            },
            NotEqual: function (condition, massageAlert) {
                if (!condition) {
                    Swal.fire({
                        title: "Warning",
                        text: massageAlert,
                        icon: "warning"
                    });
                    return;
                }
            }
        }

        // Add function to update map name
        document.getElementById("updateMapName").addEventListener("click", () => {
            const mapSelect = document.getElementById("map-select");
            const selectedIndex = mapSelect.value;
            const newMapName = document.getElementById("mapName").value;

            CheckCondition.Equal(selectedIndex, "Please select a map to update.")

            if (!newMapName && newMapName !== "") {
                Swal.fire({
                    title: "Warning",
                    text: "Please enter a new name for the map.",
                    icon: "warning"
                });
                return;
            }
            maps[selectedIndex] = { ...maps[selectedIndex], name: newMapName };

            // Refresh dropdown options
            UpdateMapSelect();
            Swal.fire({
                title: "Success",
                text: `Map ${parseInt(selectedIndex) + 1} renamed to ${newMapName}`,
                icon: "success"
            });
            // Re-select the updated map
            mapSelect.value = selectedIndex;
            console.log(`Map ${parseInt(selectedIndex) + 1} renamed to ${newMapName}`);
            document.getElementById("mapName").value = "";
        });

        // Update map select
        function UpdateMapSelect() {
            const mapSelect = document.getElementById("map-select");
            mapSelect.innerHTML = "<option value=''>Select Map</option>";
            maps.forEach((map, index) => {
                const option = document.createElement("option");
                option.value = index;
                option.textContent = map.name || `Map ${index + 1}`;
                mapSelect.appendChild(option);
            });
        }

        // Load map
        function LoadMap(mapSrc) {
            img.src = mapSrc;
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏à‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
                const selectedIndex = document.getElementById("map-select").value;
                points = pointsPerMap[selectedIndex] || [];  // ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏∏‡∏î‡∏à‡∏≤‡∏Å pointsPerMap
                markerCoordinates = markerCoordinatesPerMap[selectedIndex] || [];  // ‡πÇ‡∏´‡∏•‡∏î marker ‡∏à‡∏≤‡∏Å markerCoordinatesPerMap

                if (drawMode) {
                    DrawMarkers();
                }

                // ‡∏ß‡∏≤‡∏î‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
                points.forEach(point => {
                    DrawPoint(point.x, point.y, point.name, point.color);
                    if (point.distance > 0) {
                        DrawCircle(point.x, point.y, point.distance);
                    }
                });
            };
        }

        // Edit name map
        async function EditMapName(mapSrc) {
            const { value: mapName } = await Swal.fire({
                title: "Enter a name for this map",
                input: "text",
                inputLabel: "Map Name",
                inputValue: `Map ${maps.length + 1}`,
                showCancelButton: true,
                inputValidator: (value) => {
                    if (!value) {
                        return "You need to write something!";
                    }
                }
            });

            if (mapName) {
                Swal.fire({
                    title: "Map uploaded successfully",
                    text: `Map name: ${mapName}`,
                    icon: "success"
                });
                maps.push({ src: mapSrc, name: mapName });
                UpdateMapSelect();
                document.getElementById("map-select").value = maps.length - 1;
                LoadMap(mapSrc);
            }
        }

        // Load sample maps
        document.querySelectorAll('.map-sample').forEach(img => {
            img.addEventListener('click', () => {
                const mapSrc = img.getAttribute('data-map-src');
                EditMapName(mapSrc);

            });
        });

        // Upload map
        document.getElementById("map-upload").addEventListener("change", event => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    const mapSrc = e.target.result;
                    EditMapName(mapSrc);
                };
                reader.readAsDataURL(file);
            }
        });

        // Select map
        document.getElementById("map-select").addEventListener("change", event => {
            const selectedIndex = event.target.value;
            if (selectedIndex) {
                // ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
                LoadMap(maps[selectedIndex].src);

                document.getElementById("map-select").value = selectedIndex;
            }
        });

        // Delete map
        document.getElementById("delete-map").addEventListener("click", () => {
            const mapSelect = document.getElementById("map-select"),
                selectedIndex = mapSelect.value;
            if (maps.length === 0) {
                Swal.fire({
                    title: "No maps available",
                    text: "There are no maps to delete.",
                    icon: "warning",
                    confirmButtonText: "OK"
                });
                return;
            }
            CheckCondition.Equal(selectedIndex, "Please select a map to delete.");

            if (selectedIndex !== null && selectedIndex >= 0) {
                Swal.fire({
                    title: `Are you sure you want to delete map ${parseInt(selectedIndex) + 1}?`,
                    icon: "question",
                    confirmButtonText: "Delete",
                    cancelButtonText: "Cancel",
                    showCancelButton: true,
                    showCloseButton: true
                }).then((result) => {
                    if (result.isConfirmed) {
                        // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö
                        Swal.fire({
                            title: "Map deleted",
                            icon: "success"
                        });
                        maps.splice(selectedIndex, 1);
                        UpdateMapSelect();

                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        points = [];
                        markerCoordinates = [];

                        if (maps.length > 0) {
                            mapSelect.value = 0;
                            LoadMap(maps[0].src);  // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏•‡∏ö
                        } else {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                        console.log(`Map ${parseInt(selectedIndex) + 1} deleted`);
                    }
                });
            }
        });

        canvas.addEventListener("click", event => {
            const pointName = document.getElementById("pointName").value;
            if (maps.length === 0) {
                Swal.fire({
                    title: "Info",
                    text: "Please upload or select a map before adding points.",
                    icon: "question"
                });
                return;
            }

            if (!ValidatePoint(pointName)) return;

            const rect = canvas.getBoundingClientRect(),
                x = event.clientX - rect.left, y = event.clientY - rect.top;

            if (drawMode) AddMarkerAndPoint(x, y, pointName);
            else AddPoint(x, y, pointName);
        });

        canvas.addEventListener("mousemove", event => {
            const rect = canvas.getBoundingClientRect(),
                x = event.clientX - rect.left,
                y = event.clientY - rect.top;

            const hoveredPoint = points.find(point => {
                const dx = point.x - x;
                const dy = point.y - y;
                return Math.sqrt(dx * dx + dy * dy) < 5; // Adjust the radius as needed
            });
            // console.log(hoveredPoint);

            if (hoveredPoint) {
                tooltip.innerText = `Name: ${hoveredPoint.name}\nDistance: ${hoveredPoint.distance.toFixed(2)} m\nRSSI: ${hoveredPoint.rssi} dBm`;
                tooltip.style.display = "block";
                tooltip.style.left = `${event.pageX + 10}px`;
                tooltip.style.top = `${event.pageY + 10}px`;
            } else tooltip.style.display = "none";
        });

        function ResetCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            points = [];

            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            off(dbRef); // ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ü‡∏±‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            console.log("Firebase data listeners reset");

            console.log("Canvas, points, and circles reset");
        }

        function DrawMarkers() {
            ctx.save();
            ctx.fillStyle = "blue";
            markerCoordinates.forEach(marker => DrawMarker(marker.x, marker.y));
            ctx.restore();
        }

        function DrawMarker(x, y) {
            ctx.fillStyle = "blue";
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        function DrawPoint(x, y, name, color = "black") {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = "black";
            ctx.fillText(`${name} (${Math.round(x)}, ${Math.round(y)})`, x + 5, y - 5);
        }

        function ValidatePoint(pointName) {
            if (!pointName) {
                Swal.fire({
                    title: "Warning",
                    text: "Please enter a name for the point.",
                    icon: "warning"
                });
                return false;
            }

            for (const mapIndex in pointsPerMap) {
                if (pointsPerMap[mapIndex].some(point => point.name === pointName)) {
                    Swal.fire({
                        title: "Error",
                        text: "Point name must be unique across all maps.",
                        icon: "error"
                    });
                    return false;
                }
            }

            return true;
        }

        function AddMarkerAndPoint(x, y, name) {
            const selectedIndex = document.getElementById("map-select").value;
            if (!markerCoordinatesPerMap[selectedIndex]) markerCoordinatesPerMap[selectedIndex] = [];
            markerCoordinatesPerMap[selectedIndex].push({ x, y });
            DrawMarker(x, y);
            AddPoint(x, y, name);
        }

        function AddPoint(x, y, name) {
            if (!ValidatePoint(name)) return;

            const color = drawMode ? "blue" : "red";
            DrawPoint(x, y, name, color);

            const distance = 0;
            const rssi = "Not available";

            const selectedIndex = document.getElementById("map-select").value;
            if (!pointsPerMap[selectedIndex]) pointsPerMap[selectedIndex] = [];
            pointsPerMap[selectedIndex].push({ x, y, name, color, distance, rssi });

            console.log(`Point added: ${name} at (${x}, ${y})`);

            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Firebase ‡πÅ‡∏•‡∏∞‡∏ß‡∏≤‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏°
            CheckAndDisplayPointData({ x, y, name });

            UpdatePointSelects();
        }

        // function ToggleMode() {
        //     drawMode = !drawMode;
        //     UpdateModeIndicator();
        // }

        function ShowDistance() {
            const index1 = document.getElementById("point1Select").value;
            const index2 = document.getElementById("point2Select").value;

            if (index1 === index2) {
                Swal.fire({
                    title: "Error",
                    text: "Cannot measure distance between the same point.",
                    icon: "error"
                });
                return;
            }

            if (index1 && index2) {
                const distance = calculateDistance(points[index1], points[index2]);
                document.getElementById("distanceDisplay").innerText = `Distance between ${points[index1].name} and ${points[index2].name}: ${distance.toFixed(2)} meters`;
            }
        }

        function DeletePoint() {
            const pointSelect = document.getElementById("pointSelect");
            const selectedPointName = pointSelect.value;

            if (!selectedPointName) {
                Swal.fire({
                    title: "Info",
                    text: "Please select a point to delete.",
                    icon: "question"
                });
                return;
            }

            const mapIndex = document.getElementById("map-select").value;

            if (!pointsPerMap[mapIndex]) {
                Swal.fire({
                    title: "Info",
                    text: "No points available for the selected map.",
                    icon: "question"
                });
                return;
            }

            // ‡∏•‡∏ö‡∏à‡∏∏‡∏î‡∏à‡∏≤‡∏Å pointsPerMap
            pointsPerMap[mapIndex] = pointsPerMap[mapIndex].filter(point => point.name !== selectedPointName);

            // ‡∏•‡∏ö‡∏à‡∏∏‡∏î‡∏à‡∏≤‡∏Å markerCoordinatesPerMap
            if (markerCoordinatesPerMap[mapIndex]) {
                markerCoordinatesPerMap[mapIndex] = markerCoordinatesPerMap[mapIndex].filter(marker => marker.name !== selectedPointName);
            }

            points = pointsPerMap[mapIndex];

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            points.forEach(point => {
                DrawPoint(point.x, point.y, point.name, point.color);
                if (point.distance > 0) DrawCircle(point.x, point.y, point.distance);
            });

            UpdatePointSelects();
            console.log("Points after deletion:", points);
        }

        // function UpdateModeIndicator() {
        //     const modeIndicator = document.getElementById("modeIndicator");
        //     modeIndicator.textContent = drawMode ? "Mode: Adding Routers" : "Mode: Adding Points";
        // }

        function UpdatePointSelects() {
            const pointSelect = document.getElementById("pointSelect");
            const point1Select = document.getElementById("point1Select");
            const point2Select = document.getElementById("point2Select");
            const editPointSelect = document.getElementById("editPointSelect");

            // ‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô select
            pointSelect.innerHTML = "";
            point1Select.innerHTML = "";
            point2Select.innerHTML = "";
            editPointSelect.innerHTML = "";

            // ‡πÅ‡∏ó‡∏£‡∏Å option ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å select
            pointsPerMap.forEach((points) => {
                if (points) {
                    points.forEach(point => {
                        const option = document.createElement("option");
                        option.value = point.name; // ‡∏Ñ‡πà‡∏≤ value ‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏∏‡∏î
                        option.textContent = point.name; // ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô select

                        // ‡πÄ‡∏û‡∏¥‡πà‡∏° option ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ó‡∏∏‡∏Å select
                        pointSelect.appendChild(option.cloneNode(true));
                        point1Select.appendChild(option.cloneNode(true));
                        point2Select.appendChild(option.cloneNode(true));
                        editPointSelect.appendChild(option.cloneNode(true));
                    });
                }
            });
        }

        function CheckAndDisplayPointData(point) {
            if (point.name === "TP-Link_2536_1" || point.name === "TP-Link_2536_2") {
                const routerKey = point.name === "TP-Link_2536_1" ? "Router1" : "Router2";

                // ‡πÉ‡∏ä‡πâ onValue ‡πÅ‡∏ó‡∏ô get ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ü‡∏±‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Firebase ‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå
                onValue(ref(db, `Data/${routerKey}`), snapshot => {
                    if (snapshot.exists()) {
                        const data = snapshot.val();
                        if (data.rssi && data.Log && data.Log.distance) {
                            point.rssi = data.rssi;
                            point.distance = data.Log.distance;

                            console.log(`Data for ${point.name} found: RSSI = ${point.rssi}, Distance = ${point.distance}`);

                            updatePointDistance(point.name, point.rssi, point.distance);

                            RefreshMap();
                        } else {
                            console.log(`Data found but missing rssi or distance for ${point.name}`);
                        }
                    } else {
                        console.log(`No data found for ${point.name}`);
                    }
                }, error => {
                    console.error("Error fetching data:", error);
                });
            }
        }

        function updatePointDistance(pointName, rssi, distance) {
            const selectedIndex = document.getElementById("map-select").value;
            if (selectedIndex && pointsPerMap[selectedIndex]) {
                pointsPerMap[selectedIndex].forEach(point => {
                    if (point.name === pointName) {
                        point.rssi = rssi;
                        point.distance = distance;
                    }
                });
            }
        }

        function RefreshMap() {
            const selectedIndex = document.getElementById("map-select").value;
            if (selectedIndex && maps[selectedIndex]) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                // ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏∏‡∏î‡∏à‡∏≤‡∏Å pointsPerMap
                points = pointsPerMap[selectedIndex] || [];
                markerCoordinates = markerCoordinatesPerMap[selectedIndex] || [];

                points.forEach((point, index) => {
                    DrawPoint(point.x, point.y, point.name, point.color);
                    if (point.distance > 0) {
                        DrawCircle(point.x, point.y, point.distance);
                    }

                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡∏ß‡∏á‡∏Å‡∏•‡∏°‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏π‡πà
                    for (let i = index + 1; i < points.length; i++) {
                        CheckCircleIntersection(point, points[i]);
                    }
                });

                console.log("Map refreshed with updated points and circles.");
            }
        }

        function DrawCircle(x, y, distance) {
            if (distance > 0) {
                console.log(`Drawing circle at (${x}, ${y}) with radius: ${distance * 90}`);
                ctx.beginPath();
                ctx.arc(x, y, distance * 90, 0, 2 * Math.PI);  // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
                ctx.stroke();
            }
        }

        function CheckCircleIntersection(point1, point2) {
            
            // d = ‚àö(x1 - x2)^2 + (y1 - y2)^2  
    const d = Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
    const r1 = point1.distance * 90;
    const r2 = point2.distance * 90;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà d > r1 + r2 
    if (d > r1 + r2) {
        console.log(`Circles of ${point1.name} and ${point2.name} are close but do not intersect.`);
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ö‡∏ô‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á
        const ratio1 = r1 / d;
        const ratio2 = r2 / d;

        const nearestPoint1 = {
            x: point1.x + (point2.x - point1.x) * ratio1,
            y: point1.y + (point2.y - point1.y) * ratio1
        };

        const nearestPoint2 = {
            x: point2.x + (point1.x - point2.x) * ratio2,
            y: point2.y + (point1.y - point2.y) * ratio2
        };

        // ‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á
        DrawLine(nearestPoint1.x, nearestPoint1.y, nearestPoint2.x, nearestPoint2.y);
        DrawMidPoint(nearestPoint1.x, nearestPoint1.y, nearestPoint2.x, nearestPoint2.y);

        console.log(`Draw line between nearest points of ${point1.name} and ${point2.name}`);
        return [];
    } else if (d < Math.abs(r1 - r2) || d === 0) {
        console.log(`Circles of ${point1.name} and ${point2.name} are within each other or identical.`);
        return [];
    }

    // ‡∏´‡∏≤‡∏Å‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô (‡∏Å‡∏£‡∏ì‡∏µ‡∏õ‡∏Å‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏™‡∏≠‡∏á‡∏ß‡∏á‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô)
    //
    const a = ((r1 * r1) - (r2 * r2) + (d * d)) / (2 * d);
    const h = Math.sqrt((r1 * r1) - (a * a));

    const x3 = point1.x + (a * (point2.x - point1.x)) / d;
    const y3 = point1.y + (a * (point2.y - point1.y)) / d;

    const intersectX1 = x3 + (h * (point2.y - point1.y)) / d;
    const intersectY1 = y3 - (h * (point2.x - point1.x)) / d;
    const intersectX2 = x3 - (h * (point2.y - point1.y)) / d;
    const intersectY2 = y3 + (h * (point2.x - point1.x)) / d;

    console.log(`Intersection points for ${point1.name} and ${point2.name}:`);
    console.log(`Point 1: (${intersectX1}, ${intersectY1})`);
    console.log(`Point 2: (${intersectX2}, ${intersectY2})`);

    // ‡∏ß‡∏≤‡∏î‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏ö‡∏ô canvas
    DrawPoint(intersectX1, intersectY1, "Intersection", "green");
    DrawPoint(intersectX2, intersectY2, "Intersection", "green");

    return [
        { x: intersectX1, y: intersectY1 },
        { x: intersectX2, y: intersectY2 }
    ];
}

function DrawLine(x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';  // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÇ‡∏õ‡∏£‡πà‡∏á‡πÅ‡∏™‡∏á
    ctx.stroke();
    console.log(`Drew line from (${x1}, ${y1}) to (${x2}, ${y2})`);
}

function DrawMidPoint(x1, y1, x2, y2) {
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô
    const xMid = (x1 + x2) / 2;
    const yMid = (y1 + y2) / 2;

    // ‡∏ß‡∏≤‡∏î‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
    ctx.beginPath();
    ctx.arc(xMid, yMid, 5, 0, 2 * Math.PI);  // ‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏á‡∏Å‡∏•‡∏°‡πÄ‡∏•‡πá‡∏Å‡πÜ
    ctx.fillStyle = 'red';
    ctx.fill();
    console.log(`Midpoint at (${xMid}, ${yMid})`);
}

        document.getElementById("resetPoints").addEventListener("click", ResetCanvas);
        // document.getElementById("logPoints").addEventListener("click", logPoints);
        // document.getElementById("ToggleMode").addEventListener("click", ToggleMode);
        document.getElementById("ShowDistance").addEventListener("click", ShowDistance);
        document.getElementById("DeletePoint").addEventListener("click", DeletePoint);

        document.getElementById("editPoint").addEventListener("click", async () => {
            const selectedPointName = document.getElementById("editPointSelect").value;
            const newPointName = document.getElementById("newPointName").value;
            const mapIndex = document.getElementById("map-select").value;

            CheckCondition.NotEqual(selectedPointName, "Please select a point to edit.");

            CheckCondition.NotEqual(newPointName, "Please enter a new name for the point.");

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏∏‡∏î‡∏≠‡∏∑‡πà‡∏ô
            if (!ValidatePoint(newPointName)) {
                Swal.fire({
                    title: "Error",
                    text: "The new point name already exists.",
                    icon: "error"
                });
                return;
            }

            // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏∏‡∏î‡πÉ‡∏ô pointsPerMap
            const point = pointsPerMap[mapIndex].find(p => p.name === selectedPointName);
            if (point) {
                point.name = newPointName;
            } else {
                console.error(`Point with name "${selectedPointName}" not found.`);
                return;
            }

            // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏∏‡∏î‡πÉ‡∏ô markerCoordinatesPerMap (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
            if (markerCoordinatesPerMap[mapIndex]) {
                const marker = markerCoordinatesPerMap[mapIndex].find(m => m.name === selectedPointName);
                if (marker) {
                    marker.name = newPointName;
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            pointsPerMap[mapIndex].forEach(point => {
                DrawPoint(point.x, point.y, point.name, point.color);
                if (point.distance > 0) DrawCircle(point.x, point.y, point.distance);
            });

            // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡πÉ‡∏´‡∏°‡πà
            UpdatePointSelects();

            Swal.fire({
                title: "Success",
                text: `Point name changed to: ${newPointName}`,
                icon: "success"
            });

            document.getElementById("newPointName").value = "";
        });
        // UpdateModeIndicator();

    </script> -->
    <script type="module" src="/pages/map/js/map.js"></script>
  </body>
</html>
